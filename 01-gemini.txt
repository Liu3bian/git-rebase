这是一个非常棒的实战项目！Camunda 7 与 Spring Boot 2 的结合是目前企业级工作流开发的经典组合。

为了保证代码能直接运行且不遗漏细节，我将分模块为你提供。首先，我们需要完成环境准备、数据库设计以及后端基础架构（包括 Security 权限控制）。

第一步：创建 Spring Boot 项目结构
你可以使用 Spring Initializr 创建项目，或者直接在 IDEA 中新建。

核心依赖 (pom.xml)

XML

<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.example</groupId>
    <artifactId>camunda-leave-system</artifactId>
    <version>1.0-SNAPSHOT</version>

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.7.18</version> <relativePath/>
    </parent>

    <properties>
        <java.version>1.8</java.version>
        <camunda.version>7.20.0</camunda.version>
    </properties>

    <dependencies>
        <dependency>
            <groupId>org.camunda.bpm.springboot</groupId>
            <artifactId>camunda-bpm-spring-boot-starter-rest</artifactId>
            <version>${camunda.version}</version>
        </dependency>
        <dependency>
            <groupId>org.camunda.bpm.springboot</groupId>
            <artifactId>camunda-bpm-spring-boot-starter-webapp</artifactId>
            <version>${camunda.version}</version>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>

        <dependency>
            <groupId>com.mysql</groupId>
            <artifactId>mysql-connector-j</artifactId>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt</artifactId>
            <version>0.9.1</version>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>
</project>
第二步：数据库表设计 (SQL)
你需要先在 MySQL 中创建一个名为 camunda_db 的数据库。以下是权限系统的 5 张核心表。

SQL

CREATE DATABASE IF NOT EXISTS camunda_db DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci;
USE camunda_db;

-- 1. 用户表
CREATE TABLE `sys_user` (
  `id` BIGINT NOT NULL AUTO_INCREMENT,
  `username` VARCHAR(50) NOT NULL UNIQUE COMMENT '用户名',
  `password` VARCHAR(255) NOT NULL COMMENT '密码',
  `real_name` VARCHAR(50) DEFAULT NULL COMMENT '真实姓名',
  `department` VARCHAR(100) DEFAULT NULL COMMENT '部门',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- 2. 角色表
CREATE TABLE `sys_role` (
  `id` BIGINT NOT NULL AUTO_INCREMENT,
  `name` VARCHAR(50) NOT NULL UNIQUE COMMENT '角色名',
  `code` VARCHAR(50) NOT NULL UNIQUE COMMENT '角色代码',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- 3. 权限表 (简单起见，这里指菜单或操作权限)
CREATE TABLE `sys_permission` (
  `id` BIGINT NOT NULL AUTO_INCREMENT,
  `name` VARCHAR(50) NOT NULL,
  `perm_code` VARCHAR(50) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- 4. 用户-角色关联表
CREATE TABLE `sys_user_role` (
  `user_id` BIGINT NOT NULL,
  `role_id` BIGINT NOT NULL,
  PRIMARY KEY (`user_id`, `role_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- 5. 角色-权限关联表
CREATE TABLE `sys_role_permission` (
  `role_id` BIGINT NOT NULL,
  `permission_id` BIGINT NOT NULL,
  PRIMARY KEY (`role_id`, `permission_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- 初始化基础数据 (密码均为 123456 的加密串)
INSERT INTO `sys_user` VALUES (1, 'worker', '$2a$10$8.UnVuG9HHgffUDAlk8qfOuVGkqRzgVymGe07xd00dmG8shLiVn9G', '张员工', '技术部');
INSERT INTO `sys_user` VALUES (2, 'manager', '$2a$10$8.UnVuG9HHgffUDAlk8qfOuVGkqRzgVymGe07xd00dmG8shLiVn9G', '李主管', '管理层');

INSERT INTO `sys_role` VALUES (1, '普通员工', 'ROLE_WORKER');
INSERT INTO `sys_role` VALUES (2, '审批主管', 'ROLE_MANAGER');

INSERT INTO `sys_user_role` VALUES (1, 1);
INSERT INTO `sys_user_role` VALUES (2, 2);
第三步：后端配置文件 (application.yml)
请确保修改数据库连接信息为你本地的配置。

YAML

server:
  port: 8080

spring:
  datasource:
    url: jdbc:mysql://localhost:3306/camunda_db?serverTimezone=Asia/Shanghai&useUnicode=true&characterEncoding=utf-8&useSSL=false
    username: root
    password: yourpassword
    driver-class-name: com.mysql.cj.jdbc.Driver

  jpa:
    hibernate:
      ddl-auto: update # 自动同步 Camunda 的表结构
    show-sql: true

camunda.bpm:
  admin-user:
    id: admin
    password: admin
  filter:
    create: All tasks # 自动创建一个查看所有任务的过滤器
下一步预告
目前的步骤完成了项目的“地基”。为了能让你跑起来，我接下来需要为你提供：

Security 核心配置类：实现 JWT 登录和数据库用户校验。

Entity 与 Repository：对应上述 SQL 表的 Java 代码。

BPMN 流程文件：绘制请假流程图。

你是否已经准备好了 MySQL 环境并创建了上述数据库？如果是，请告诉我，我将立即为你提供后端 Security 验证和核心业务实体的代码。


好的，既然需要使用 Java 17，我们将对项目进行微调。Spring Boot 2.7.x 是支持 Java 17 的。

在 Java 17 环境下，我们需要注意反射权限和部分库的兼容性。下面是完整的后端第一部分：项目环境、依赖管理、数据库模型以及 JWT 安全认证实现。

第一步：修改 pom.xml (针对 Java 17)
XML

<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.example</groupId>
    <artifactId>camunda-leave-system</artifactId>
    <version>1.0-SNAPSHOT</version>

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.7.18</version>
    </parent>

    <properties>
        <java.version>17</java.version>
        <camunda.version>7.20.0</camunda.version>
        <jjwt.version>0.9.1</jjwt.version>
    </properties>

    <dependencies>
        <dependency>
            <groupId>org.camunda.bpm.springboot</groupId>
            <artifactId>camunda-bpm-spring-boot-starter-rest</artifactId>
            <version>${camunda.version}</version>
        </dependency>
        <dependency>
            <groupId>org.camunda.bpm.springboot</groupId>
            <artifactId>camunda-bpm-spring-boot-starter-webapp</artifactId>
            <version>${camunda.version}</version>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>

        <dependency>
            <groupId>com.mysql</groupId>
            <artifactId>mysql-connector-j</artifactId>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>

        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt</artifactId>
            <version>${jjwt.version}</version>
        </dependency>
        <dependency>
            <groupId>javax.xml.bind</groupId>
            <artifactId>jaxb-api</artifactId>
            <version>2.3.1</version>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <excludes>
                        <exclude>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                        </exclude>
                    </excludes>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
第二步：数据库实体类 (Entity)
在 src/main/java/com/example/entity 目录下创建以下类。

1. 用户实体 SysUser.java

Java

package com.example.entity;

import lombok.Data;
import javax.persistence.*;
import java.util.Set;

@Data
@Entity
@Table(name = "sys_user")
public class SysUser {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(unique = true, nullable = false)
    private String username;

    @Column(nullable = false)
    private String password;

    private String realName;
    private String department;

    @ManyToMany(fetch = FetchType.EAGER)
    @JoinTable(
        name = "sys_user_role",
        joinColumns = @JoinColumn(name = "user_id"),
        inverseJoinColumns = @JoinColumn(name = "role_id")
    )
    private Set<SysRole> roles;
}
2. 角色实体 SysRole.java

Java

package com.example.entity;

import lombok.Data;
import javax.persistence.*;

@Data
@Entity
@Table(name = "sys_role")
public class SysRole {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;
    private String code; // 例如 ROLE_WORKER, ROLE_MANAGER
}
第三步：安全认证核心 (Security & JWT)
这是最复杂的部分，确保用户能够登录并获得令牌。

1. JWT 工具类 JwtUtils.java

Java

package com.example.security;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import org.springframework.stereotype.Component;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;

@Component
public class JwtUtils {
    private String secret = "my_secret_key_123456";
    private Long expiration = 604800L; // 7天

    public String generateToken(String username) {
        Map<String, Object> claims = new HashMap<>();
        return Jwts.builder()
                .setClaims(claims)
                .setSubject(username)
                .setIssuedAt(new Date())
                .setExpiration(new Date(System.currentTimeMillis() + expiration * 1000))
                .signWith(SignatureAlgorithm.HS512, secret)
                .compact();
    }

    public String getUsernameFromToken(String token) {
        return Jwts.parser().setSigningKey(secret).parseClaimsJws(token).getBody().getSubject();
    }

    public boolean validateToken(String token) {
        try {
            Jwts.parser().setSigningKey(secret).parseClaimsJws(token);
            return true;
        } catch (Exception e) {
            return false;
        }
    }
}
2. 安全过滤类 JwtAuthenticationFilter.java

Java

package com.example.security;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;
import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@Component
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    @Autowired
    private JwtUtils jwtUtils;
    @Autowired
    private UserDetailsService userDetailsService;

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
            throws ServletException, IOException {
        String authHeader = request.getHeader("Authorization");
        if (authHeader != null && authHeader.startsWith("Bearer ")) {
            String token = authHeader.substring(7);
            if (jwtUtils.validateToken(token)) {
                String username = jwtUtils.getUsernameFromToken(token);
                UserDetails userDetails = userDetailsService.loadUserByUsername(username);
                UsernamePasswordAuthenticationToken authentication =
                        new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());
                SecurityContextHolder.getContext().setAuthentication(authentication);
            }
        }
        filterChain.doFilter(request, response);
    }
}
第四步：启动类 (Application.java)
Java

package com.example;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class LeaveSystemApplication {
    public static void main(String[] args) {
        SpringApplication.run(LeaveSystemApplication.class, args);
    }
}
当前状态说明
数据库：请沿用上一条回答中的 SQL 语句创建表（Java 17 并不改变 SQL 结构）。

Java 版本：已适配 Java 17，解决了 jjwt 在高版本 Java 中的反射依赖问题（添加了 jaxb-api）。

下一步操作：

我将为你提供 UserRepository 以及 UserDetailsService 的实现，这是登录的核心。

随后提供 LoginController 让你可以通过 Postman 获取 Token。

最后进入 Camunda 流程设计与前端 Vue 代码。

是否已经成功创建项目并导入了这些代码？如果 OK，我将继续提供权限系统的具体实现代码。


太棒了，我们现在继续。这一步是整个系统的核心“中枢”，负责用户认证逻辑、Security 配置以及Camunda 流程引擎的初步集成。

按照你的要求，代码都是完整的，包括所有 import。

第四步：持久层与服务层（User Repository & Service）
在 src/main/java/com/example/repository 目录下：

1. SysUserRepository.java

Java

package com.example.repository;

import com.example.entity.SysUser;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import java.util.Optional;

@Repository
public interface SysUserRepository extends JpaRepository<SysUser, Long> {
    // 根据用户名查询用户，用于登录
    Optional<SysUser> findByUsername(String username);
}
在 src/main/java/com/example/security 目录下：

2. UserDetailsServiceImpl.java

Java

package com.example.security;

import com.example.entity.SysUser;
import com.example.repository.SysUserRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

import java.util.stream.Collectors;

@Service
public class UserDetailsServiceImpl implements UserDetailsService {

    @Autowired
    private SysUserRepository userRepository;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        SysUser sysUser = userRepository.findByUsername(username)
                .orElseThrow(() -> new UsernameNotFoundException("用户不存在: " + username));

        return new User(
                sysUser.getUsername(),
                sysUser.getPassword(),
                sysUser.getRoles().stream()
                        .map(role -> new SimpleGrantedAuthority(role.getCode()))
                        .collect(Collectors.toList())
        );
    }
}
第五步：Spring Security 核心配置（SecurityConfig）
这里配置了哪些接口需要登录，哪些不需要，以及如何处理跨域（Vue前端必须）。

在 src/main/java/com/example/config 目录下：

SecurityConfig.java

Java

package com.example.config;

import com.example.security.JwtAuthenticationFilter;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
import org.springframework.web.filter.CorsFilter;

@Configuration
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Autowired
    private UserDetailsService userDetailsService;

    @Autowired
    private JwtAuthenticationFilter jwtAuthenticationFilter;

    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.userDetailsService(userDetailsService).passwordEncoder(passwordEncoder());
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    @Override
    public AuthenticationManager authenticationManagerBean() throws Exception {
        return super.authenticationManagerBean();
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.csrf().disable()
            // 开启跨域
            .cors().and()
            // 基于token，不需要session
            .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS).and()
            .authorizeRequests()
            // 登录接口和静态资源放行
            .antMatchers("/auth/login", "/camunda/**", "/lib/**").permitAll()
            // 其它所有请求都需要认证
            .anyRequest().authenticated();

        // 添加JWT过滤器
        http.addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);
    }

    // 跨域配置，对接Vue前端
    @Bean
    public CorsFilter corsFilter() {
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        CorsConfiguration config = new CorsConfiguration();
        config.setAllowCredentials(true);
        config.addAllowedOriginPattern("*");
        config.addAllowedHeader("*");
        config.addAllowedMethod("*");
        source.registerCorsConfiguration("/**", config);
        return new CorsFilter(source);
    }
}
第六步：登录控制器（AuthController）
用于前端调用，返回 JWT Token 以及用户的基本信息。

在 src/main/java/com/example/controller 目录下：

AuthController.java

Java

package com.example.controller;

import com.example.entity.SysUser;
import com.example.repository.SysUserRepository;
import com.example.security.JwtUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

import java.util.HashMap;
import java.util.Map;

@RestController
@RequestMapping("/auth")
public class AuthController {

    @Autowired
    private AuthenticationManager authenticationManager;

    @Autowired
    private JwtUtils jwtUtils;

    @Autowired
    private SysUserRepository userRepository;

    @PostMapping("/login")
    public Map<String, Object> login(@RequestBody Map<String, String> loginDto) {
        String username = loginDto.get("username");
        String password = loginDto.get("password");

        // 1. 验证用户名密码
        Authentication authentication = authenticationManager.authenticate(
                new UsernamePasswordAuthenticationToken(username, password)
        );

        // 2. 生成Token
        String token = jwtUtils.generateToken(username);

        // 3. 获取用户信息返回给前端
        SysUser user = userRepository.findByUsername(username).get();

        Map<String, Object> result = new HashMap<>();
        result.code(20000); // 适配 vue-admin-template 的状态码
        Map<String, Object> data = new HashMap<>();
        data.put("token", token);
        data.put("name", user.getRealName());
        data.put("roles", user.getRoles());
        result.put("data", data);

        return result;
    }

    // vue-admin-template 需要的 info 接口
    @GetMapping("/info")
    public Map<String, Object> info(@RequestParam String token) {
        String username = jwtUtils.getUsernameFromToken(token);
        SysUser user = userRepository.findByUsername(username).get();

        Map<String, Object> result = new HashMap<>();
        result.put("code", 20000);
        Map<String, Object> data = new HashMap<>();
        data.put("roles", user.getRoles().stream().map(r -> r.getCode()).toArray());
        data.put("name", user.getRealName());
        data.put("avatar", "https://wpimg.wallstcn.com/f778738c-e4f8-4870-b634-56703b4acafe.gif");
        data.put("introduction", user.getDepartment());
        result.put("data", data);
        return result;
    }
}
注意： 在 AuthController 中，我为了适配 vue-admin-template 的默认返回格式，手动构造了 code: 20000 的返回体。

下一步预告：
至此，基础架构和登录权限已经完全就绪。 接下来的核心内容将是：

Camunda 流程文件 (leave.bpmn)：我们将定义请假流程的图形化逻辑。

LeaveController：实现“发起请假”、“待办列表”、“已办列表”、“审批任务”的接口。

前端 Vue 代码：配置 API 拦截器和创建请假表单页面。

请确认你是否已经将这些类放到了对应的包路径下？完成后，我将提供 Camunda 的流程图设计和业务 Controller 代码。


现在我们进入最核心的部分：Camunda 流程定义与业务接口开发。

由于你是一个小白，这一步非常关键：我们需要创建一个 .bpmn 文件，它是 Camunda 引擎识别的“剧本”。

第七步：创建请假流程文件 (leave.bpmn)
在 src/main/resources 目录下新建一个文件夹 bpmn，然后创建一个文件 leave.bpmn。

提示：这个文件本质是 XML。如果你安装了 Camunda Modeler 软件可以直接打开它。为了直接运行，请直接把下面的代码复制进去。

XML

<?xml version="1.0" encoding="UTF-8"?>
<bpmn:definitions xmlns:bpmn="http://www.omg.org/spec/BPMN/20100524/MODEL" xmlns:bpmndi="http://www.omg.org/spec/BPMN/20100524/DI" xmlns:dc="http://www.omg.org/spec/DD/20100524/DC" xmlns:camunda="http://camunda.org/schema/1.0/bpmn" xmlns:di="http://www.omg.org/spec/DD/20100524/DI" id="Definitions_1" targetNamespace="http://bpmn.io/schema/bpmn" exporter="Camunda Modeler" exporterVersion="5.0.0">
  <bpmn:process id="leave_process" name="请假流程" isExecutable="true">
    <bpmn:startEvent id="StartEvent_1" name="开始" camunda:initiator="applyUserId">
      <bpmn:outgoing>Flow_1</bpmn:outgoing>
    </bpmn:startEvent>
    <bpmn:sequenceFlow id="Flow_1" sourceRef="StartEvent_1" targetRef="Activity_Approve" />
    <bpmn:userTask id="Activity_Approve" name="主管审批" camunda:assignee="manager">
      <bpmn:incoming>Flow_1</bpmn:incoming>
      <bpmn:outgoing>Flow_2</bpmn:outgoing>
    </bpmn:userTask>
    <bpmn:endEvent id="EndEvent_1" name="结束">
      <bpmn:incoming>Flow_2</bpmn:incoming>
    </bpmn:endEvent>
    <bpmn:sequenceFlow id="Flow_2" sourceRef="Activity_Approve" targetRef="EndEvent_1" />
  </bpmn:process>
  <bpmndi:BPMNDiagram id="BPMNDiagram_1">
    <bpmndi:BPMNPlane id="BPMNPlane_1" bpmnElement="leave_process">
      <bpmndi:BPMNEdge id="Flow_1_di" bpmnElement="Flow_1">
        <di:waypoint x="215" y="117" />
        <di:waypoint x="270" y="117" />
      </bpmndi:BPMNEdge>
      <bpmndi:BPMNEdge id="Flow_2_di" bpmnElement="Flow_2">
        <di:waypoint x="370" y="117" />
        <di:waypoint x="432" y="117" />
      </bpmndi:BPMNEdge>
      <bpmndi:BPMNShape id="_BPMNShape_StartEvent_2" bpmnElement="StartEvent_1">
        <dc:Bounds x="179" y="99" width="36" height="36" />
      </bpmndi:BPMNShape>
      <bpmndi:BPMNShape id="Activity_0q8q4ws_di" bpmnElement="Activity_Approve">
        <dc:Bounds x="270" y="77" width="100" height="80" />
      </bpmndi:BPMNShape>
      <bpmndi:BPMNShape id="Event_0nz98ow_di" bpmnElement="EndEvent_1">
        <dc:Bounds x="432" y="99" width="36" height="36" />
      </bpmndi:BPMNShape>
    </bpmndi:BPMNPlane>
  </bpmndi:BPMNDiagram>
</bpmn:definitions>
第八步：业务控制器 (LeaveController)
这个类处理前端发来的所有请求：发起请假、查询我的任务、审批任务。

在 src/main/java/com/example/controller 目录下创建：

LeaveController.java

Java

package com.example.controller;

import org.camunda.bpm.engine.HistoryService;
import org.camunda.bpm.engine.RuntimeService;
import org.camunda.bpm.engine.TaskService;
import org.camunda.bpm.engine.history.HistoricProcessInstance;
import org.camunda.bpm.engine.runtime.ProcessInstance;
import org.camunda.bpm.engine.task.Task;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.bind.annotation.*;

import java.util.*;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/leave")
public class LeaveController {

    @Autowired
    private RuntimeService runtimeService;

    @Autowired
    private TaskService taskService;

    @Autowired
    private HistoryService historyService;

    // 1. 发起流程
    @PostMapping("/start")
    public Map<String, Object> startLeave(@RequestBody Map<String, Object> variables) {
        String currentUsername = SecurityContextHolder.getContext().getAuthentication().getName();

        // 设置流程变量（姓名、日期、原因等）
        variables.put("applyUserId", currentUsername);

        // 启动流程实例，key 必须与 bpmn 文件中的 id 一致
        ProcessInstance instance = runtimeService.startProcessInstanceByKey("leave_process", variables);

        Map<String, Object> result = new HashMap<>();
        result.put("code", 20000);
        result.put("data", "流程发起成功，ID: " + instance.getId());
        return result;
    }

    // 2. 查询当前用户的待办任务
    @GetMapping("/todo")
    public Map<String, Object> getTodoList() {
        String currentUsername = SecurityContextHolder.getContext().getAuthentication().getName();

        // 查询指派给当前人的任务
        List<Task> tasks = taskService.createTaskQuery()
                .taskAssignee(currentUsername)
                .list();

        List<Map<String, Object>> taskList = tasks.stream().map(task -> {
            Map<String, Object> map = new HashMap<>();
            map.put("taskId", task.getId());
            map.put("taskName", task.getName());
            map.put("processInstanceId", task.getProcessInstanceId());
            map.put("createTime", task.getCreateTime());
            // 获取流程变量（请假详情）
            map.put("variables", taskService.getVariables(task.getId()));
            return map;
        }).collect(Collectors.toList());

        Map<String, Object> result = new HashMap<>();
        result.put("code", 20000);
        result.put("data", taskList);
        return result;
    }

    // 3. 审批任务（完成任务）
    @PostMapping("/approve")
    public Map<String, Object> approveTask(@RequestBody Map<String, String> body) {
        String taskId = body.get("taskId");

        // 完成任务
        taskService.complete(taskId);

        Map<String, Object> result = new HashMap<>();
        result.put("code", 20000);
        result.put("data", "审批成功");
        return result;
    }

    // 4. 查询当前用户的已办任务（历史记录）
    @GetMapping("/done")
    public Map<String, Object> getDoneList() {
        String currentUsername = SecurityContextHolder.getContext().getAuthentication().getName();

        List<HistoricProcessInstance> list = historyService.createHistoricProcessInstanceQuery()
                .variableValueEquals("applyUserId", currentUsername)
                .finished()
                .list();

        Map<String, Object> result = new HashMap<>();
        result.put("code", 20000);
        result.put("data", list);
        return result;
    }
}
第九步：前端项目准备
现在后端基本完工，我们需要让 vue-admin-template 能和后端说话。

修改前端 vue.config.js 中的 Proxy（防止跨域）: 找到 devServer 部分：

JavaScript

proxy: {
  [process.env.VUE_APP_BASE_API]: {
    target: `http://localhost:8080`, // 指向你的 Spring Boot
    changeOrigin: true,
    pathRewrite: {
      ['^' + process.env.VUE_APP_BASE_API]: ''
    }
  }
}
修改 src/api/user.js: 将登录相关的 URL 修改为我们后端对应的接口（/auth/login 和 /auth/info）。

下一步操作
后端代码现在已经具备了：

权限验证

Camunda 流程部署

请假业务逻辑

你是否已经成功将 leave.bpmn 放入 resources 文件夹并创建了 Controller？ 如果是，下一步我将为你提供 Vue 前端页面的完整代码，包括请假表单和待办列表表格。


这一步我们将完成 Vue 前端项目 的核心代码。我们将基于 vue-admin-template 进行修改。

由于前端项目文件较多，我将为你提供最关键的 4 个部分：API 定义、请求拦截器修改、请假发起页面、待办/已办列表页面。

第一步：修改前端 src/utils/request.js
确保前端在每次请求时，都会把登录时获取的 token 放在 Header 里传给后端。

JavaScript

import axios from 'axios'
import { MessageBox, Message } from 'element-ui'
import store from '@/store'
import { getToken } from '@/utils/auth'

const service = axios.create({
  baseURL: process.env.VUE_APP_BASE_API,
  timeout: 5000
})

// 请求拦截器
service.interceptors.request.use(
  config => {
    if (store.getters.token) {
      // 让每个请求携带 token
      config.headers['Authorization'] = 'Bearer ' + getToken()
    }
    return config
  },
  error => {
    return Promise.reject(error)
  }
)

// 响应拦截器
service.interceptors.response.use(
  response => {
    const res = response.data
    // vue-admin-template 默认成功码是 20000
    if (res.code !== 20000) {
      Message({
        message: res.message || 'Error',
        type: 'error',
        duration: 5 * 1000
      })
      return Promise.reject(new Error(res.message || 'Error'))
    } else {
      return res
    }
  },
  error => {
    Message({
      message: error.message,
      type: 'error',
      duration: 5 * 1000
    })
    return Promise.reject(error)
  }
)

export default service
第二步：定义 API 接口 (src/api/leave.js)
在 src/api 目录下新建 leave.js，对应后端的 LeaveController。

JavaScript

import request from '@/utils/request'

// 发起请假
export function startLeave(data) {
  return request({
    url: '/leave/start',
    method: 'post',
    data
  })
}

// 获取待办任务
export function getTodoList() {
  return request({
    url: '/leave/todo',
    method: 'get'
  })
}

// 审批任务
export function approveTask(data) {
  return request({
    url: '/leave/approve',
    method: 'post',
    data
  })
}

// 获取已办任务
export function getDoneList() {
  return request({
    url: '/leave/done',
    method: 'get'
  })
}
第三步：发起请假页面 (src/views/leave/index.vue)
创建一个包含你要求的“姓名、工号、部门、科室、原因、日期”的表单页面。

代码段

<template>
  <div class="app-container">
    <el-form ref="form" :model="form" label-width="120px">
      <el-form-item label="姓名">
        <el-input v-model="form.name" />
      </el-form-item>
      <el-form-item label="工号">
        <el-input v-model="form.jobNum" />
      </el-form-item>
      <el-form-item label="部门">
        <el-input v-model="form.dept" />
      </el-form-item>
      <el-form-item label="科室">
        <el-input v-model="form.section" />
      </el-form-item>
      <el-form-item label="请假日期">
        <el-date-picker v-model="form.leaveDate" type="date" value-format="yyyy-MM-dd" placeholder="选择日期" />
      </el-form-item>
      <el-form-item label="请假原因">
        <el-input v-model="form.reason" type="textarea" />
      </el-form-item>
      <el-form-item>
        <el-button type="primary" @click="onSubmit">提交申请</el-button>
      </el-form-item>
    </el-form>
  </div>
</template>

<script>
import { startLeave } from '@/api/leave'

export default {
  data() {
    return {
      form: {
        name: '',
        jobNum: '',
        dept: '',
        section: '',
        leaveDate: '',
        reason: ''
      }
    }
  },
  methods: {
    onSubmit() {
      startLeave(this.form).then(response => {
        this.$message({ message: '发起成功！', type: 'success' })
        this.form = {} // 清空表单
      })
    }
  }
}
</script>
第四步：待办列表页面 (src/views/leave/todo.vue)
主管登录后在这个页面进行审批。

代码段

<template>
  <div class="app-container">
    <el-table :data="list" border style="width: 100%">
      <el-table-column prop="variables.name" label="申请人" />
      <el-table-column prop="variables.dept" label="部门" />
      <el-table-column prop="variables.leaveDate" label="请假日期" />
      <el-table-column prop="variables.reason" label="原因" />
      <el-table-column prop="createTime" label="申请时间" />
      <el-table-column label="操作">
        <template slot-scope="scope">
          <el-button size="mini" type="success" @click="handleApprove(scope.row.taskId)">同意</el-button>
        </template>
      </el-table-column>
    </el-table>
  </div>
</template>

<script>
import { getTodoList, approveTask } from '@/api/leave'

export default {
  data() {
    return {
      list: []
    }
  },
  created() {
    this.fetchData()
  },
  methods: {
    fetchData() {
      getTodoList().then(res => {
        this.list = res.data
      })
    },
    handleApprove(taskId) {
      approveTask({ taskId: taskId }).then(res => {
        this.$message({ message: '审批成功', type: 'success' })
        this.fetchData() // 刷新列表
      })
    }
  }
}
</script>
第五步：运行指南
后端启动：运行 Spring Boot 的 main 方法。它会自动在数据库中创建 Camunda 所需的几十张表。

前端启动：

在前端项目根目录运行 npm install。

运行 npm run dev。

测试流程：

登录员工账号：用户名 worker，密码 123456。

发起请假：进入“发起请假”页面，填表提交。

登录主管账号：退出登录，换 manager 登录。

审批任务：在“待办列表”中点击“同意”。

最后提示：

不要忘记在 src/router/index.js 中添加这两页面的路由映射，否则侧边栏看不到。

后端数据库连接密码一定要改对。

至此，一个从 0 开始的 Spring Boot 2 + Camunda 7 + Vue 的完整请假流程系统已经交付完毕！如果有任何运行报错，请直接粘贴错误信息给我。