在使用 vue-admin-template 与 Spring Security 集成的过程中，403 Forbidden 通常意味着 身份验证已通过，但权限不足 或者 CSRF 防护拦截了非 GET 请求。

既然你使用了 admin 账户，且能成功登录（说明 401 认证没问题），那么问题通常出在以下三个地方：

1. Spring Security 的 CSRF 防护（最常见原因）
Spring Security 默认开启了 CSRF 保护。对于 POST、PUT、DELETE 请求，如果请求头中没有携带 CSRF Token，服务器会直接返回 403。

解决方法： 在你的 SecurityConfig.java 中禁用 CSRF（前后端分离项目通常靠 JWT 保证安全，可以禁用 CSRF）。

Java

@Configuration
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.csrf().disable() // 必须禁用这一项
            .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS) // 禁用 Session
            .and()
            .authorizeRequests()
            .antMatchers("/auth/**").permitAll() // 登录接口放行
            .anyRequest().authenticated(); // 其他接口需要认证

        // 添加你的 JWT 过滤器...
    }
}
2. 接口权限注解不匹配
检查你的 Controller 接口上是否使用了 @PreAuthorize 注解，且其中的角色代码与数据库不一致。

排查步骤：

检查数据库 sys_role 表，admin 对应的 code 是不是 ROLE_ADMIN。

检查 Controller 代码：

Java

// 确保这里的角色名和数据库里完全一致（包括 ROLE_ 前缀）
@PreAuthorize("hasRole('ROLE_ADMIN')")
@GetMapping("/users")
public Result listUsers() { ... }
关键点：Spring Security 在处理角色时，默认会给 hasRole('ADMIN') 自动补全 ROLE_ 前缀。如果你的数据库里存的是 ADMIN，而代码写的是 hasRole('ROLE_ADMIN')，就会匹配失败报 403。

3. JWT 过滤器未正确提取角色
如果后端没有把数据库里的角色信息装载到 UsernamePasswordAuthenticationToken 中，Security 就不知道 admin 到底有什么权限。

检查你的 JwtAuthenticationTokenFilter.java（或类似名称）：

Java

// 在解析 Token 后，构建权限列表
List<SimpleGrantedAuthority> authorities = new ArrayList<>();
// 假设你把角色存在了 claims 里，或者需要查库获取
List<String> roles = (List<String>) claims.get("roles");
for (String role : roles) {
    authorities.add(new SimpleGrantedAuthority(role)); // role 必须是 "ROLE_ADMIN" 这种格式
}

UsernamePasswordAuthenticationToken authentication =
    new UsernamePasswordAuthenticationToken(userDetails, null, authorities); // 必须传入 authorities
SecurityContextHolder.getContext().setAuthentication(authentication);
4. 前端请求拦截器 (src/utils/request.js)
确认前端在发送请求时，请求头是否正确携带了 X-Token 或 Authorization。

调试建议：

查看后端控制台：Spring Security 报错通常会有 AccessDeniedException。

查看浏览器 Network：点击那个红色的 403 请求，看 Request Headers 里是否有 Authorization: Bearer xxxx。

临时测试：在 SecurityConfig 中把报错的接口暂时设为 .antMatchers("/api/user/**").permitAll()，看是否还报 403。如果不报了，百分之百是权限/角色字符串比对没对上。

下一步建议
你可以把你的 SecurityConfig.java 和报错接口的 Controller 代码发给我，我帮你直接定位是哪个字符串写错了。你现在数据库里 admin 对应的角色 Code 到底带不带 ROLE_ 前缀？


这是非常关键的一点。在 Spring Security 中，仅仅登录成功是不够的，必须在每次请求的拦截器里，把解析出来的角色信息重新塞回 Security 的上下文中。否则，尽管你带了 Token，Security 也会认为你是一个“没有任何权限的合法用户”，从而报 403 错误。

 由于我们之前没有实现这个拦截器，现在我们需要创建一个 JwtAuthenticationFilter。

 第一步：创建 JwtAuthenticationFilter
 这个过滤器的作用是：拦截每一个请求 -> 提取 Token -> 解析出用户名和角色 -> 告诉 Spring Security 当前用户是谁，有什么角色。

 Java

 package com.example.config;

 import com.example.utils.JwtUtils;
 import io.jsonwebtoken.Claims;
 import org.springframework.beans.factory.annotation.Autowired;
 import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
 import org.springframework.security.core.authority.SimpleGrantedAuthority;
 import org.springframework.security.core.context.SecurityContextHolder;
 import org.springframework.stereotype.Component;
 import org.springframework.web.filter.OncePerRequestFilter;

 import javax.servlet.FilterChain;
 import javax.servlet.ServletException;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
 import java.io.IOException;
 import java.util.List;
 import java.util.stream.Collectors;

 @Component
 public class JwtAuthenticationFilter extends OncePerRequestFilter {

     @Autowired
     private JwtUtils jwtUtils;

     @Override
     protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
             throws ServletException, IOException {

         // 1. 从请求头获取 Token
         String token = request.getHeader("Authorization");
         if (token != null && token.startsWith("Bearer ")) {
             token = token.substring(7);
             try {
                 // 2. 解析 Token
                 Claims claims = jwtUtils.parseToken(token);
                 String username = claims.getSubject();

                 // 3. 从 Claims 中提取角色列表
                 // 注意：我们在登录生成 Token 时，必须把 roles 放进去，这里才能取出来
                 List<String> roles = (List<String>) claims.get("roles");

                 if (username != null && SecurityContextHolder.getContext().getAuthentication() == null) {
                     // 4. 将角色字符串转换为 Spring Security 识别的 GrantedAuthority 对象
                     List<SimpleGrantedAuthority> authorities = roles.stream()
                             .map(SimpleGrantedAuthority::new)
                             .collect(Collectors.toList());

                     // 5. 构建认证对象
                     UsernamePasswordAuthenticationToken authentication =
                             new UsernamePasswordAuthenticationToken(username, null, authorities);

                     // 6. 存入上下文，这样后续的 @PreAuthorize("hasRole('ADMIN')") 才能生效
                     SecurityContextHolder.getContext().setAuthentication(authentication);
                 }
             } catch (Exception e) {
                 // Token 无效或过期，不处理，Security 会自动拦截并返回 403 或 401
             }
         }
         filterChain.doFilter(request, response);
     }
 }
 第二步：修改 JwtUtils 中的生成 Token 方法
 你必须确保在登录时，角色信息已经被写入了 JWT 的 Claims 中。请检查你的 JwtUtils.java：

 Java

 public String createToken(String username, List<String> roles) {
     return Jwts.builder()
             .setSubject(username)
             .claim("roles", roles) // 这一行至关重要！
             .setExpiration(new Date(System.currentTimeMillis() + expiration))
             .signWith(SignatureAlgorithm.HS512, secret)
             .compact();
 }
 第三步：将过滤器配置到 SecurityConfig
 你需要告诉 Spring Security 在处理权限判断之前，先执行我们写的这个 JwtAuthenticationFilter。

 Java

 @Configuration
 @EnableWebSecurity
 @EnableGlobalMethodSecurity(prePostEnabled = true) // 开启注解权限控制
 public class SecurityConfig extends WebSecurityConfigurerAdapter {

     @Autowired
     private JwtAuthenticationFilter jwtAuthenticationFilter;

     @Override
     protected void configure(HttpSecurity http) throws Exception {
         http.csrf().disable() // 禁用 CSRF
             .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS) // 无状态
             .and()
             .authorizeRequests()
             .antMatchers("/auth/login").permitAll() // 登录放行
             .anyRequest().authenticated(); // 其他全拦截

         // 关键：在 UsernamePasswordAuthenticationFilter 之前添加 JWT 过滤器
         http.addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);
     }
 }
 第四步：核对数据库权限字符串
 Spring Security 的 hasRole('ADMIN') 默认匹配的是数据库中以 ROLE_ 开头的字符串。

 如果你的数据库存的是 ROLE_ADMIN，代码写 @PreAuthorize("hasRole('ADMIN')")。

 如果你的数据库存的是 ADMIN，代码写 @PreAuthorize("hasRole('ADMIN')") 就会报 403。此时你应该改为使用 @PreAuthorize("hasAuthority('ADMIN')")。

 总结解决流程
 登录时：后端把 ROLE_ADMIN 存入 JWT。

 请求时：JwtAuthenticationFilter 拦截请求，解析出 ROLE_ADMIN。

 注入：使用 new SimpleGrantedAuthority("ROLE_ADMIN") 注入到 Security 上下文。

 校验：@PreAuthorize 发现上下文中有这个权限，放行。

 按照这个步骤修改后，尝试重新登录 admin 账号，403 应该就会消失。如果还有问题，可以在控制台打印一下 authorities 的内容，看看是不是空的？


 非常抱歉，之前的代码确实遗漏了核心的解析逻辑。在 Spring Security + JWT 的体系中，JwtUtils 必须同时具备 生成（create） 和 解析（parse） 两个对称的功能。

 以下是一个完整的、生产可用的 JwtUtils 类。它使用了目前主流的 io.jsonwebtoken 库。

 1. 完整 JwtUtils.java 类
 Java

 package com.example.utils;

 import io.jsonwebtoken.Claims;
 import io.jsonwebtoken.Jwts;
 import io.jsonwebtoken.SignatureAlgorithm;
 import org.springframework.stereotype.Component;

 import java.util.Date;
 import java.util.List;
 import java.util.Map;

 @Component
 public class JwtUtils {

     // 秘钥：实际项目中建议从 yml 配置文件读取
     private String secret = "my_secret_key_1234567890_very_secure";

     // 过期时间：默认 24 小时 (单位：毫秒)
     private long expiration = 86400000;

     /**
      * 生成 Token
      * @param username 用户名 (Subject)
      * @param roles 角色列表 (作为自定义 Claim 存入)
      */
     public String createToken(String username, List<String> roles) {
         return Jwts.builder()
                 .setSubject(username)
                 .claim("roles", roles) // 将权限角色信息写入载荷
                 .setIssuedAt(new Date())
                 .setExpiration(new Date(System.currentTimeMillis() + expiration))
                 .signWith(SignatureAlgorithm.HS512, secret)
                 .compact();
     }

     /**
      * 解析 Token (这就是你之前报错缺失的方法)
      * @param token 客户端传来的字符串
      * @return 包含用户名和角色的 Claims 对象
      */
     public Claims parseToken(String token) {
         try {
             return Jwts.parser()
                     .setSigningKey(secret)
                     .parseClaimsJws(token)
                     .getBody();
         } catch (Exception e) {
             // 如果 token 过期、被篡改，这里会抛出异常
             return null;
         }
     }

     /**
      * 判断 Token 是否有效
      */
     public boolean validateToken(String token) {
         Claims claims = parseToken(token);
         return claims != null && !isTokenExpired(claims);
     }

     /**
      * 检查是否过期
      */
     private boolean isTokenExpired(Claims claims) {
         return claims.getExpiration().before(new Date());
     }
 }
 2. 这个类如何配合解决 403 报错？
 403 报错是因为 Security 不知道你的角色。现在有了这个 parseToken，你可以在 JwtAuthenticationFilter 中这样调用：

 Java

 // 在拦截器中获取 Claims
 Claims claims = jwtUtils.parseToken(token);

 if (claims != null) {
     String username = claims.getSubject();
     // 从 claims 中还原出生成时存入的 "roles" 列表
     List<String> roles = (List<String>) claims.get("roles");

     // 将其转换为 Security 需要的权限格式
     List<SimpleGrantedAuthority> authorities = roles.stream()
             .map(SimpleGrantedAuthority::new)
             .collect(Collectors.toList());

     // 重新构建并存入 SecurityContextHolder
     UsernamePasswordAuthenticationToken authentication =
             new UsernamePasswordAuthenticationToken(username, null, authorities);
     SecurityContextHolder.getContext().setAuthentication(authentication);
 }
 3. 注意事项 (针对 Admin 账户)
 角色前缀一致性：如果数据库里存的是 ROLE_ADMIN，那么 claims.get("roles") 取出来的就是 ROLE_ADMIN。在 Controller 上使用 @PreAuthorize("hasRole('ADMIN')") 时，Spring 会自动去匹配 ROLE_ADMIN。

 依赖注入：确保你在 JwtAuthenticationFilter 中使用的是 @Autowired private JwtUtils jwtUtils;，而不是手动 new 出来的。

 总结
 没有 parseToken 就像有锁没有钥匙。现在补全了这个方法后，后端在处理 admin 访问 用户管理 或 角色管理 接口时，就能从 Token 里的 Payload 区域“读出”该用户的管理员身份，从而允许访问。

 建议你现在尝试把这个类替换进去，并重启后端。如果尝试登录 admin 后依然 403，请在拦截器里 System.out.println(roles) 打印一下，看看是否真的拿到了 ROLE_ADMIN。


 引入了完整的 JwtUtils 和 JwtAuthenticationFilter 后，确实会产生“牵一发而动全身”的效果。为了让整个安全体系闭环，你需要重点重写或修改以下三个核心类：

 AuthController.java：修改登录逻辑，在生成 Token 时将角色存入。

 SecurityConfig.java：将新的过滤器配置到过滤链中，并开启方法级权限开关。

 UserDetailServiceImpl.java（或登录逻辑处）：确保查询用户信息时带上角色。

 以下是具体的重写方案：

 1. 修改 AuthController.java (登录逻辑)
 在登录成功后，必须获取用户的角色列表，并传给 jwtUtils.createToken。

 Java

 @RestController
 @RequestMapping("/auth")
 public class AuthController {

     @Autowired
     private JwtUtils jwtUtils;
     @Autowired
     private UserService userService; // 假设你有查询用户的服务
     @Autowired
     private PasswordEncoder passwordEncoder;

     @PostMapping("/login")
     public Result login(@RequestBody Map<String, String> loginDto) {
         String username = loginDto.get("username");
         String password = loginDto.get("password");

         // 1. 查询用户
         SysUser user = userService.getByUsername(username);
         if (user == null || !passwordEncoder.matches(password, user.getPassword())) {
             return Result.error("用户名或密码错误");
         }

         // 2. 获取用户角色列表 (例如: ["ROLE_ADMIN", "ROLE_WORKER"])
         // 这一步非常重要，必须把角色查出来
         List<String> roles = userService.getUserRoles(user.getId());

         // 3. 生成包含角色的 Token
         String token = jwtUtils.createToken(username, roles);

         Map<String, Object> map = new HashMap<>();
         map.put("token", token);
         return Result.success(map);
     }
 }
 2. 修改 SecurityConfig.java (核心配置)
 你需要开启 @EnableGlobalMethodSecurity 并配置 JwtAuthenticationFilter。

 Java

 @Configuration
 @EnableWebSecurity
 @EnableGlobalMethodSecurity(prePostEnabled = true) // 必须开启，否则 @PreAuthorize 失效
 public class SecurityConfig extends WebSecurityConfigurerAdapter {

     @Autowired
     private JwtAuthenticationFilter jwtAuthenticationFilter;

     @Bean
     public PasswordEncoder passwordEncoder() {
         return new BCryptPasswordEncoder();
     }

     @Override
     protected void configure(HttpSecurity http) throws Exception {
         http.csrf().disable()
             .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)
             .and()
             .authorizeRequests()
             .antMatchers("/auth/login").permitAll()
             .antMatchers("/auth/logout").permitAll()
             // 允许跨域的 OPTIONS 请求
             .antMatchers(HttpMethod.OPTIONS, "/**").permitAll()
             .anyRequest().authenticated();

         // 将 JWT 过滤器放在用户名密码认证过滤器之前
         http.addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);

         // 禁用缓存
         http.headers().cacheControl();
     }
 }
 3. 修改管理功能的 Controller (权限控制)
 确保在用户管理、角色管理等接口上添加了权限限制。

 UserController.java 示例：

 Java

 @RestController
 @RequestMapping("/system/user")
 public class UserController {

     // 只有拥有 ROLE_ADMIN 角色的用户才能访问
     @PreAuthorize("hasRole('ADMIN')")
     @GetMapping("/list")
     public Result list() {
         // ... 查询逻辑
         return Result.success(userList);
     }

     @PreAuthorize("hasRole('ADMIN')")
     @PostMapping("/add")
     public Result add(@RequestBody SysUser user) {
         // ... 增加逻辑
         return Result.success("添加成功");
     }
 }
 4. 前端 src/store/modules/user.js (可选检查)
 检查前端在调用 getInfo（获取用户信息）时，是否能正确拿到角色。

 如果你的 getInfo 接口也是通过解析 Token 来返回信息的，那么后端 getInfo 接口也需要重写：

 Java

 @GetMapping("/info")
 public Result getInfo() {
     // 从 Security 上下文中获取当前用户名和权限
     Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
     String username = (String) authentication.getPrincipal();
     List<String> roles = authentication.getAuthorities().stream()
             .map(item -> item.getAuthority())
             .collect(Collectors.toList());

     Map<String, Object> map = new HashMap<>();
     map.put("roles", roles);
     map.put("name", username);
     map.put("avatar", "https://wpimg.wallstcn.com/f778738c-e4f8-4870-b634-56703b4acafe.gif");
     return Result.success(map);
 }
 总结
 你主要需要修改的地方是：

 登录接口：生成 Token 时必须把角色存入 claim。

 Security 配置：开启注解权限支持并挂载过滤器。

 业务接口：使用 @PreAuthorize 保护敏感接口。

 按照这个结构重构后，admin 账号在访问管理页面时，拦截器会自动从 Token 中读取角色，Security 校验通过，403 错误就会消失。